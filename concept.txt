Концепт написания программы с неблокирующим сокетом на взаимодействие.

Шаги:
	1. Проверка кол-ва аргументов программы. Должен приходить порт, как аргумент.

	2. Инициализация структуры с данными для подключения - sockaddr_in:
		a. Объявление;
		b. bzero - зануление;
		c. Объявили порт - uint16_t port = atoi(av[1]).

	3. Проставляем поля структуры:
		a. sin_family = AF_INET;
		b. sin_addr.s_addr = htol(2130706433);
		c. sin_port = htons(port);

	4. Создаём сокет с помощью int socket(...) с AF_INET, SOCK_STREAM и 0.

	5. Биндим сокет на соединение (выдаём ему адрес) - int bind(...):
		a. sock_fd;
		b. (const struct sockaddr *)&servaddr - наша структура с инфой;
		c. sizeof(servaddr);

	6. После создания сокета переводим его в слушающий режим. int listen(...)
	То есть на этом сокете может быть произведена лишь одна операция - приём соединения.
	При установлении соединения ядро ОС (сервера, то есть наша) создаст новый сокет,
	который будет использоваться для передачи данных по только установленному соединению.

	7. У нас есть два множества сокетов:
		a. curr_sock - сокеты, с которыми мы работаем;
		b. cpy_read, cpy_write - сокеты на I/O.
	curr_sock мы должны занулить и добавить в него sock_fd - наш слушающий сокет.
	А так же занулить tmp, buf, str (Массивы char-ов для работы с сообщениями) в bzero.

	8. Дальше стартует runloop while(1) {} - Это способ построение программ, при котором
	программа имеет главный цикл и внутри него реагирует на события из определённого
	множества, а действия программ как реакция на событие - event-driven programming.
	В данном случае у нас есть два события:
		a. Подключение клиента к серверу;
		b. Обработка данных из клиентских сокетов.

	9. Дальше через int select(...) мы проверяем произошло ли событие.
	if select(...) < 0: continue

	10. Если select > 0, тогда мы пробегаемся по всем fd-кам.
		- Событие произошло в сокете? FD_ISSET(fd, $cpy_read)
			- Это новый запрос? fd == sock_fd?
				- Добавляем клиента: bzero(&msg, ...); add_client(); break
			- Пришли данные на прочтение из клиентского сокета?
				- TODO: Описать, что здесть делать
				- После окончания прочтения сообщения проверяем, произошла ли ошибка.
					- Если да, то удаляем клиента и закрываем дескриптор.
					bzero(&msg, ...);
					sprintf(msg, "server: client %d just left\n", rm_client(fd));
					send_all(fd, msg);
					FD_CLR(fd, &curr_sock);
					close(fd);
					break;
				- Если ошибки не произошло - обрабатываем сообщение: ex_msg(fd);

	

